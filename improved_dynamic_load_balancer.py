#!/usr/bin/env python3
"""
Improved Dynamic Load Balancer Test Script for Mannequin Segmenter API
Generates random pulover URLs to a file, then uses each URL individually for requests
"""

import asyncio
import aiohttp
import time
import statistics
from datetime import datetime
import json
from collections import deque
import random
import csv
import os

# ========== KONFIGUR√ÅCI√ìS PARAM√âTEREK ==========
TEST_DURATION_SECONDS = 30  # Teszt fut√°si ideje m√°sodpercben
TOTAL_REQUESTS = 50         # √ñsszes k√©r√©sek sz√°ma amit fel akarunk dolgozni
REQUEST_TIMEOUT = 60        # Timeout m√°sodpercben
CSV_FILE = "data_for_categorisation.csv"
URL_LIST_FILE = "pulover_urls.txt"

# VM Instance IP c√≠mek
VM_INSTANCES = [
    "http://34.22.130.174:5001",
    "http://34.79.218.203:5001", 
    "http://104.155.15.184:5001",
    "http://35.195.4.217:5001",
    "http://34.140.252.94:5001"
]

# API endpoint
API_ENDPOINT = "/infer"

# ===============================================

def extract_pulover_urls_from_csv(csv_file, count):
    """Kiv√°laszt random pulover URL-eket a CSV-b≈ël"""
    pulover_urls = []
    
    print(f"üìñ CSV f√°jl olvas√°sa: {csv_file}")
    
    try:
        with open(csv_file, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            
            for line_num, line in enumerate(lines[1:], 2):  # Skip header
                line = line.strip()
                if not line:
                    continue
                    
                # Split by comma and clean up
                parts = line.split(',')
                if len(parts) >= 3:
                    full_name = parts[1].lower()
                    image_url = parts[2]
                    
                    # Ellen≈ërizz√ºk hogy pulover van a nev√©ben vagy a kateg√≥ri√°ban √©s b.jpg v√©gz≈ëd√©s≈±
                    if ('pulover' in full_name or '–ø—É–ª–æ–≤–µ—Ä–∏' in full_name) and image_url.endswith('b.jpg'):
                        pulover_urls.append(image_url)
        
        print(f"üîç √ñsszesen tal√°lt pulover k√©pek (b.jpg): {len(pulover_urls)}")
        
        # Random kiv√°laszt√°s
        if len(pulover_urls) < count:
            print(f"‚ö†Ô∏è  Csak {len(pulover_urls)} k√©p el√©rhet≈ë, az √∂sszeset haszn√°ljuk")
            selected_urls = pulover_urls
        else:
            selected_urls = random.sample(pulover_urls, count)
        
        print(f"‚úÖ Kiv√°lasztott k√©pek sz√°ma: {len(selected_urls)}")
        return selected_urls
        
    except Exception as e:
        print(f"‚ùå Hiba a CSV olvas√°sakor: {e}")
        return []

def save_urls_to_file(urls, filename):
    """URL-ek ment√©se f√°jlba"""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            for url in urls:
                f.write(url + '\n')
        print(f"üíæ URL-ek elmentve: {filename} ({len(urls)} darab)")
        return True
    except Exception as e:
        print(f"‚ùå Hiba a f√°jl ment√©sekor: {e}")
        return False

def load_urls_from_file(filename):
    """URL-ek bet√∂lt√©se f√°jlb√≥l"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            urls = [line.strip() for line in f if line.strip()]
        print(f"üìÇ URL-ek bet√∂ltve: {filename} ({len(urls)} darab)")
        return urls
    except Exception as e:
        print(f"‚ùå Hiba a f√°jl olvas√°sakor: {e}")
        return []

class InstanceState:
    def __init__(self, url):
        self.url = url
        self.is_busy = False
        self.current_task_id = None
        self.completed_tasks = 0
        self.total_response_time = 0.0
        self.errors = 0
        self.last_completed = None
        # Concurrency guard
        self.in_flight = 0
        self.violations = 0

class ImprovedDynamicLoadBalancer:
    def __init__(self, image_urls):
        self.instances = [InstanceState(url) for url in VM_INSTANCES]
        self.image_urls = image_urls
        self.task_queue = deque()
        self.completed_results = []
        self.errors = []
        self.start_time = None
        self.next_task_id = 1
        
        # Felt√∂ltj√ºk a task queue-t - minden k√©r√©s K√úL√ñN URL-t kap
        for i in range(min(TOTAL_REQUESTS, len(image_urls))):
            self.task_queue.append({
                "task_id": i + 1,
                "payload": {
                    "image_url": image_urls[i],  # Minden task k√ºl√∂n URL-t kap
                    "prompt_mode": "both"
                }
            })
        
        print(f"üìã Task queue felt√∂ltve {len(self.task_queue)} egyedi URL-lel")
    
    def get_available_instance(self):
        """Visszaad egy szabad instance-t, ha van"""
        for instance in self.instances:
            if not instance.is_busy:
                return instance
        return None
    
    def get_next_task(self):
        """Kivesz egy task-ot a queue-b√≥l"""
        if self.task_queue:
            return self.task_queue.popleft()
        return None
    
    async def execute_task(self, session, instance, task):
        """V√©grehajtja a task-ot egy adott instance-on"""
        # Concurrency guard start
        instance.in_flight += 1
        if instance.in_flight > 1:
            instance.violations += 1
            print(f"‚ö†Ô∏è  CONCURRENCY VIOLATION on {instance.url} (in_flight={instance.in_flight})")
        instance.is_busy = True
        instance.current_task_id = task["task_id"]
        
        full_url = f"{instance.url}{API_ENDPOINT}"
        request_start = time.time()
        
        # URL r√∂vid megjelen√≠t√©se
        image_url = task["payload"]["image_url"]
        short_url = image_url.split('/')[-1][:30] + "..." if len(image_url.split('/')[-1]) > 30 else image_url.split('/')[-1]
        
        print(f"üîÑ Task {task['task_id']}: {instance.url} -> {short_url}", end="", flush=True)
        
        try:
            async with session.post(
                full_url,
                json=task["payload"],
                timeout=aiohttp.ClientTimeout(total=REQUEST_TIMEOUT)
            ) as response:
                response_text = await response.text()
                request_end = time.time()
                response_time = request_end - request_start
                
                result = {
                    "task_id": task["task_id"],
                    "instance_url": instance.url,
                    "status_code": response.status,
                    "response_time": response_time,
                    "timestamp": request_start,
                    "success": response.status == 200,
                    "response_size": len(response_text),
                    "image_url": task["payload"]["image_url"]
                }
                
                if response.status == 200:
                    try:
                        json_response = json.loads(response_text)
                        result["has_visualization_url"] = "visualization_url" in json_response
                        if "timing" in json_response:
                            result["server_timing"] = json_response["timing"]
                            # Server timing r√©szletek kinyer√©se
                            if "model_inference_time" in json_response["timing"]:
                                result["model_time"] = json_response["timing"]["model_inference_time"]
                            if "gcs_upload_time" in json_response["timing"]:
                                result["gcs_time"] = json_response["timing"]["gcs_upload_time"]
                    except json.JSONDecodeError:
                        result["has_visualization_url"] = False
                
                self.completed_results.append(result)
                
                # Instance statisztik√°k friss√≠t√©se
                instance.completed_tasks += 1
                instance.total_response_time += response_time
                instance.last_completed = time.time()
                
                # Server timing megjelen√≠t√©se ha van
                timing_str = ""
                if response.status == 200 and "model_time" in result and "gcs_time" in result:
                    timing_str = f" (model: {result['model_time']:.2f}s, gcs: {result['gcs_time']:.2f}s)"
                print(f" ‚úÖ {response.status} ({response_time:.2f}s){timing_str}")
                
        except asyncio.TimeoutError:
            request_end = time.time()
            response_time = request_end - request_start
            error = {
                "task_id": task["task_id"],
                "instance_url": instance.url,
                "error": "Timeout",
                "response_time": response_time,
                "timestamp": request_start,
                "image_url": task["payload"]["image_url"]
            }
            self.errors.append(error)
            instance.errors += 1
            print(f" ‚è∞ TIMEOUT ({response_time:.2f}s)")
            
        except Exception as e:
            request_end = time.time()
            response_time = request_end - request_start
            error = {
                "task_id": task["task_id"],
                "instance_url": instance.url,
                "error": str(e),
                "response_time": response_time,
                "timestamp": request_start,
                "image_url": task["payload"]["image_url"]
            }
            self.errors.append(error)
            instance.errors += 1
            print(f" ‚ùå ERROR: {e}")
        
        # Instance felszabad√≠t√°sa + concurrency guard end
        instance.is_busy = False
        instance.current_task_id = None
        instance.in_flight = max(0, instance.in_flight - 1)
    
    async def instance_worker(self, session, instance):
        """Worker egy adott instance-hoz - folyamatosan dolgozik"""
        while True:
            # Ellen≈ërizz√ºk hogy van-e m√©g munka √©s nincs-e id≈ët√∫ll√©p√©s
            current_time = time.time()
            if (current_time - self.start_time >= TEST_DURATION_SECONDS and 
                len(self.task_queue) == 0):
                break
                
            if current_time - self.start_time >= TEST_DURATION_SECONDS:
                print(f"‚è∞ {instance.url}: Id≈ët√∫ll√©p√©s, le√°ll√≠t√°s")
                break
            
            # Pr√≥b√°lunk task-ot szerezni
            task = self.get_next_task()
            if task is None:
                # Nincs t√∂bb task, v√°runk egy kicsit
                await asyncio.sleep(0.1)
                continue
            
            # V√©grehajtjuk a task-ot
            await self.execute_task(session, instance, task)
    
    async def run_test(self):
        """F≈ë teszt futtat√°s"""
        print(f"üöÄ Improved Dynamic Load Balancer Teszt - Egyedi Pulover K√©pekkel")
        print(f"üìä Konfigur√°ci√≥:")
        print(f"   - Teszt id≈ëtartam: {TEST_DURATION_SECONDS} m√°sodperc")
        print(f"   - √ñsszes task: {len(self.task_queue)}")
        print(f"   - VM instance-ok: {len(VM_INSTANCES)}")
        print(f"   - Request timeout: {REQUEST_TIMEOUT}s")
        print(f"   - Strat√©gia: Minden instance max 1 task egyszerre")
        print(f"   - K√©pek: Minden task EGYEDI pulover k√©pet haszn√°l")
        print()
        
        for i, instance in enumerate(self.instances):
            print(f"   VM {i+1}: {instance.url}")
        print()
        
        self.start_time = time.time()
        
        async with aiohttp.ClientSession() as session:
            # Minden instance-hoz egy worker task
            tasks = []
            for instance in self.instances:
                task = asyncio.create_task(self.instance_worker(session, instance))
                tasks.append(task)
            
            # Progress monitoring task
            monitor_task = asyncio.create_task(self.progress_monitor())
            tasks.append(monitor_task)
            
            # V√°rjuk meg az √∂sszes worker befejez√©s√©t
            await asyncio.gather(*tasks, return_exceptions=True)
        
        print(f"\n‚è±Ô∏è  Teszt befejezve!")
        self.print_statistics()
    
    async def progress_monitor(self):
        """Folyamatosan monitorozza a progresst"""
        while True:
            await asyncio.sleep(3)  # 3 m√°sodpercenk√©nt
            
            current_time = time.time()
            elapsed = current_time - self.start_time
            
            if elapsed >= TEST_DURATION_SECONDS:
                break
            
            completed = len(self.completed_results)
            remaining = len(self.task_queue)
            busy_instances = sum(1 for inst in self.instances if inst.is_busy)
            successful = len([r for r in self.completed_results if r["success"]])
            
            print(f"üìä Progress: {completed} k√©sz ({successful} sikeres), {remaining} v√°rakozik, {busy_instances}/{len(self.instances)} instance dolgozik ({elapsed:.0f}s)")
    
    def print_statistics(self):
        """Statisztik√°k ki√≠r√°sa"""
        successful_requests = [r for r in self.completed_results if r["success"]]
        failed_requests = len(self.completed_results) - len(successful_requests)
        total_requests = len(self.completed_results) + len(self.errors)
        
        print(f"\nüìà TESZT EREDM√âNYEK - EGYEDI PULOVER K√âPEK")
        print(f"=" * 70)
        print(f"‚è±Ô∏è  Teszt id≈ëtartam: {TEST_DURATION_SECONDS} m√°sodperc")
        print(f"üìä √ñsszes task: {len(self.task_queue) + total_requests}")
        print(f"‚úÖ Befejezett task-ok: {total_requests}")
        print(f"üîÑ Feldolgozatlan task-ok: {len(self.task_queue)}")
        print(f"‚úÖ Sikeres k√©r√©sek: {len(successful_requests)}")
        print(f"‚ùå Sikertelen k√©r√©sek: {failed_requests + len(self.errors)}")
        if total_requests > 0:
            print(f"üìà Sikeress√©g ar√°ny: {len(successful_requests)/total_requests*100:.1f}%")
        
        if successful_requests:
            response_times = [r["response_time"] for r in successful_requests]
            
            print(f"\n‚è∞ V√ÅLASZID≈ê STATISZTIK√ÅK (sikeres k√©r√©sek)")
            print(f"   üîπ Minimum: {min(response_times):.3f} m√°sodperc")
            print(f"   üîπ Maximum: {max(response_times):.3f} m√°sodperc")
            print(f"   üîπ √Åtlag: {statistics.mean(response_times):.3f} m√°sodperc")
            print(f"   üîπ Medi√°n: {statistics.median(response_times):.3f} m√°sodperc")
            
            # Instance-onk√©nti teljes√≠tm√©ny
            print(f"\nüñ•Ô∏è  INSTANCE-ONK√âNTI TELJES√çTM√âNY")
            for i, instance in enumerate(self.instances):
                print(f"   VM {i+1} ({instance.url}):")
                print(f"      - Befejezett task-ok: {instance.completed_tasks}")
                print(f"      - Hib√°k: {instance.errors}")
                print(f"      - Concurrency violations: {instance.violations}")
                if instance.completed_tasks > 0:
                    avg_time = instance.total_response_time / instance.completed_tasks
                    print(f"      - √Åtlag v√°laszid≈ë: {avg_time:.3f}s")
                    
                    # Instance-specifikus task-ok
                    instance_results = [r for r in successful_requests if r["instance_url"] == instance.url]
                    if instance_results:
                        instance_times = [r["response_time"] for r in instance_results]
                        print(f"      - Min/Max: {min(instance_times):.3f}s / {max(instance_times):.3f}s")
                else:
                    print(f"      - √Åtlag v√°laszid≈ë: N/A")
            
            # Throughput sz√°m√≠t√°s
            if successful_requests:
                actual_test_duration = max([r["timestamp"] for r in successful_requests]) - min([r["timestamp"] for r in successful_requests])
                if actual_test_duration > 0:
                    throughput = len(successful_requests) / actual_test_duration
                    print(f"\nüöÄ THROUGHPUT")
                    print(f"   üîπ Sikeres k√©r√©sek/m√°sodperc: {throughput:.2f}")
                    print(f"   üîπ √Åtlagos instance terhel√©s: {throughput/len(self.instances):.2f} k√©r√©s/sec/instance")
        
        # Queue √©s task-ok st√°tusza
        print(f"\nüìã TASK QUEUE STATISZTIK√ÅK")
        print(f"   üîπ Eredeti task-ok: {len(self.task_queue) + total_requests}")
        print(f"   üîπ Befejezett: {len(self.completed_results) + len(self.errors)}")
        print(f"   üîπ Feldolgozatlan: {len(self.task_queue)}")
        
        # √ñsszes fut√°s eredm√©nye
        if successful_requests:
            print(f"\nüñºÔ∏è  √ñSSZES SIKERES FUT√ÅS EREDM√âNYE")
            for i, result in enumerate(successful_requests, 1):
                short_url = result['image_url'].split('/')[-1]
                instance_name = result['instance_url'].split('/')[-1].split(':')[0]
                timing_details = ""
                if "model_time" in result and "gcs_time" in result:
                    timing_details = f" (model: {result['model_time']:.2f}s, gcs: {result['gcs_time']:.2f}s)"
                print(f"   {i:2d}. Task {result['task_id']:2d} | {instance_name:13s} | {short_url:50s} | {result['response_time']:6.2f}s{timing_details}")
        
        # Sikertelen fut√°sok
        failed_all = [r for r in self.completed_results if not r["success"]] + self.errors
        if failed_all:
            print(f"\n‚ùå √ñSSZES SIKERTELEN FUT√ÅS")
            for i, result in enumerate(failed_all, 1):
                if 'image_url' in result:
                    short_url = result['image_url'].split('/')[-1]
                    instance_name = result['instance_url'].split('/')[-1].split(':')[0]
                    error_msg = result.get('error', f'HTTP {result.get("status_code", "Unknown")}')
                    print(f"   {i:2d}. Task {result['task_id']:2d} | {instance_name:13s} | {short_url:50s} | {error_msg}")
                else:
                    print(f"   {i:2d}. {result}")
        
        # Mint√°kat is megtartjuk
        if successful_requests:
            print(f"\nüñºÔ∏è  SIKERES K√âPEK MINT√ÅI (els≈ë 5)")
            sample_size = min(5, len(successful_requests))
            for i, result in enumerate(successful_requests[:sample_size]):
                short_url = result['image_url'].split('/')[-1]
                print(f"   {i+1}. {short_url} ({result['response_time']:.2f}s)")
        
        # Hib√°k r√©szletez√©se
        if self.errors:
            print(f"\n‚ùå HIB√ÅK R√âSZLETEZ√âSE")
            error_types = {}
            for error in self.errors:
                error_type = error["error"]
                if error_type not in error_types:
                    error_types[error_type] = 0
                error_types[error_type] += 1
            
            for error_type, count in error_types.items():
                print(f"   üîπ {error_type}: {count} alkalom")

def main():
    """F≈ë program bel√©p√©si pont"""
    print("üîß Improved Mannequin Segmenter Dynamic Load Balancer Test")
    print("=" * 70)
    
    # Ellen≈ërizz√ºk hogy van-e m√°r URL f√°jl
    if os.path.exists(URL_LIST_FILE):
        print(f"üìÇ URL f√°jl m√°r l√©tezik: {URL_LIST_FILE}")
        recreate = input("üîÑ √öj URL-eket gener√°ljunk? (y/n): ").lower().strip()
        
        if recreate == 'y' or recreate == 'yes':
            print("üîÑ √öj URL-ek gener√°l√°sa...")
            urls = extract_pulover_urls_from_csv(CSV_FILE, TOTAL_REQUESTS)
            if urls:
                save_urls_to_file(urls, URL_LIST_FILE)
            else:
                print("‚ùå Nem siker√ºlt URL-eket gener√°lni")
                return
        else:
            print("üìÇ Megl√©v≈ë URL f√°jl haszn√°lata...")
    else:
        print(f"üÜï URL f√°jl nem l√©tezik, √∫j gener√°l√°s: {URL_LIST_FILE}")
        urls = extract_pulover_urls_from_csv(CSV_FILE, TOTAL_REQUESTS)
        if urls:
            save_urls_to_file(urls, URL_LIST_FILE)
        else:
            print("‚ùå Nem siker√ºlt URL-eket gener√°lni")
            return
    
    # URL-ek bet√∂lt√©se
    image_urls = load_urls_from_file(URL_LIST_FILE)
    if not image_urls:
        print("‚ùå Nem siker√ºlt URL-eket bet√∂lteni")
        return
    
    print(f"üéØ {len(image_urls)} egyedi pulover k√©p bet√∂ltve a teszthez")
    
    # Load balancer teszt futtat√°sa
    balancer = ImprovedDynamicLoadBalancer(image_urls)
    asyncio.run(balancer.run_test())

if __name__ == "__main__":
    main()
